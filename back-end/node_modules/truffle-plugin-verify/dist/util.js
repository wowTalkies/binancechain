"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getApiKey = exports.getAddressFromStorage = exports.deepCopy = exports.getRpcSendFunction = exports.getImplementationAddress = exports.getNetwork = exports.getAbsolutePath = exports.normaliseContractPath = exports.enforceOrThrow = exports.enforce = exports.abort = void 0;
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const constants_1 = require("./constants");
const abort = (message, logger = console, code = 1) => {
    logger.error(message);
    process.exit(code);
};
exports.abort = abort;
const enforce = (condition, message, logger, code) => {
    if (!condition)
        (0, exports.abort)(message, logger, code);
};
exports.enforce = enforce;
const enforceOrThrow = (condition, message) => {
    if (!condition)
        throw new Error(message);
};
exports.enforceOrThrow = enforceOrThrow;
/**
 * The metadata in the Truffle artifact file changes source paths on Windows. Instead of
 * D:\Hello\World.sol, it looks like /D/Hello/World.sol. When trying to read this path,
 * Windows cannot find it, since it is not a valid path. This function changes
 * /D/Hello/World.sol to D:\Hello\World.sol. This way, Windows is able to read these source
 * files. It does not change regular Unix paths, only Unixified Windows paths. It also does
 * not make any changes on platforms that aren't Windows.
 */
const normaliseContractPath = (contractPath, options) => {
    // Replace the 'project:' prefix that was added in Truffle v5.3.14 with the actual project path
    const absolutePath = (0, exports.getAbsolutePath)(contractPath, options);
    // If the current platform is not Windows, the path does not need to be changed
    if (process.platform !== 'win32')
        return absolutePath;
    // If the contract path doesn't start with '/[A-Z]/' it is not a Unixified Windows path
    if (!absolutePath.match(/^\/[A-Z]\//i))
        return absolutePath;
    const driveLetter = absolutePath.substring(1, 2);
    const normalisedContractPath = path_1.default.resolve(`${driveLetter}:/${absolutePath.substring(3)}`);
    return normalisedContractPath;
};
exports.normaliseContractPath = normaliseContractPath;
const getAbsolutePath = (contractPath, options) => {
    // Older versions of truffle already used the absolute path
    // Also node_modules contracts don't use the project: prefix
    if (!contractPath.startsWith('project:/'))
        return contractPath;
    const relativeContractPath = contractPath.replace('project:/', '');
    const absolutePath = path_1.default.join(options.projectDir, relativeContractPath);
    return absolutePath;
};
exports.getAbsolutePath = getAbsolutePath;
/**
 * If the network config includes a provider we use it to retrieve the network info
 * for the network. If that fails, we fall back to the config's network ID.
 */
const getNetwork = (config, logger) => __awaiter(void 0, void 0, void 0, function* () {
    const send = (0, exports.getRpcSendFunction)(config.provider);
    const fallback = { chainId: config.network_id, networkId: config.network_id };
    if (!send) {
        logger.debug('No (valid) provider configured, using config network ID as fallback');
        return fallback;
    }
    try {
        logger.debug("Retrieving network's network ID & chain ID");
        const chainIdResult = yield send({ jsonrpc: '2.0', id: Date.now(), method: 'eth_chainId', params: [] });
        const networkIdResult = yield send({ jsonrpc: '2.0', id: Date.now(), method: 'net_version', params: [] });
        const chainId = chainIdResult && Number.parseInt(chainIdResult.result, 16);
        const networkId = networkIdResult && Number.parseInt(networkIdResult.result, 10);
        // Throw an error that gets caught by the try-catch
        if (!networkId || !chainId) {
            throw new Error('Could not retrieve network chain ID or network ID');
        }
        return { chainId, networkId };
    }
    catch (_a) {
        logger.debug('Failed to retrieve network information, using configurated network ID instead');
        return fallback;
    }
});
exports.getNetwork = getNetwork;
/**
 * Check whether the address is an EIP1967 proxy and if so, return its implementation address. Note that only the LOGIC
 * variety of EIP1967 is supported, not the BEACON variety. If support for BEACON proxies is added to the openzeppelin
 * plugin, I will add it here as well
 */
const getImplementationAddress = (address, logger, provider) => __awaiter(void 0, void 0, void 0, function* () {
    const send = (0, exports.getRpcSendFunction)(provider);
    if (!send) {
        logger.debug('No (valid) provider configured, assuming no proxy');
        return undefined;
    }
    try {
        const { result } = yield send({
            jsonrpc: '2.0',
            id: Date.now(),
            method: 'eth_getStorageAt',
            params: [address, constants_1.StorageSlot.LOGIC, 'latest'],
        });
        const implementationAddress = (0, exports.getAddressFromStorage)(result);
        if (typeof result === 'string' && implementationAddress !== constants_1.NULL_ADDRESS) {
            return implementationAddress;
        }
    }
    catch (_b) {
        // ignored
    }
    return undefined;
});
exports.getImplementationAddress = getImplementationAddress;
const getRpcSendFunction = (provider) => (provider === null || provider === void 0 ? void 0 : provider.sendAsync)
    ? (0, util_1.promisify)(provider.sendAsync.bind(provider))
    : (provider === null || provider === void 0 ? void 0 : provider.send)
        ? (0, util_1.promisify)(provider.send.bind(provider))
        : undefined;
exports.getRpcSendFunction = getRpcSendFunction;
const deepCopy = (obj) => JSON.parse(JSON.stringify(obj));
exports.deepCopy = deepCopy;
const getAddressFromStorage = (storage) => `0x${storage.slice(2).slice(-40).padStart(40, '0')}`;
exports.getAddressFromStorage = getAddressFromStorage;
const getApiKey = (config, apiUrl, logger) => {
    var _a, _b;
    const networkConfig = config.networks[config.network];
    if (networkConfig && networkConfig.verify && networkConfig.verify.apiKey) {
        return networkConfig.verify.apiKey;
    }
    (0, exports.enforce)(config.api_keys, 'No API Keys provided', logger);
    const platform = new URL(apiUrl).hostname.split('.').at(-2);
    let subPlatform = (_a = new URL(apiUrl).hostname.split('.').at(-3)) === null || _a === void 0 ? void 0 : _a.split('-').at(-1);
    // For some reason Etherscan uses both optimistic.etherscan.io and optimism.etherscan.io
    if (subPlatform === 'optimism')
        subPlatform = 'optimistic';
    const apiKey = (_b = config.api_keys[`${subPlatform}_${platform}`]) !== null && _b !== void 0 ? _b : config.api_keys[platform];
    (0, exports.enforce)(apiKey, `No ${platform} or ${subPlatform}_${platform} API Key provided`, logger);
    return apiKey;
};
exports.getApiKey = getApiKey;
