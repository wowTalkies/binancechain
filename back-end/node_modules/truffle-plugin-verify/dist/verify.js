"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const delay_1 = __importDefault(require("delay"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const querystring_1 = __importDefault(require("querystring"));
const tunnel_1 = __importDefault(require("tunnel"));
const constants_1 = require("./constants");
const util_1 = require("./util");
const cliLogger = require('cli-logger');
const logger = cliLogger({ level: 'info' });
module.exports = (config) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    // Set debug logging
    if (config.debug)
        logger.level('debug');
    logger.debug('DEBUG logging is turned ON');
    logger.debug(`Running truffle-plugin-verify v${constants_1.VERSION}`);
    if (config.verify && config.verify.proxy) {
        const { proxy } = config.verify;
        logger.debug('Enable verify proxy ', proxy);
        axios_1.default.interceptors.request.use((conf) => {
            conf.httpsAgent = tunnel_1.default.httpsOverHttp({ proxy });
            conf.proxy = false;
            return conf;
        });
    }
    const options = yield parseConfig(config);
    // Verify each contract
    const contractNameAddressPairs = config._.slice(1);
    // Track which contracts failed verification
    const failedContracts = [];
    for (const contractNameAddressPair of contractNameAddressPairs) {
        logger.info(`Verifying ${contractNameAddressPair}`);
        try {
            const [contractName, contractAddress] = contractNameAddressPair.split('@');
            // If we pass a custom proxy contract, we use its artifact to trigger proxy verification
            const artifact = getArtifact((_a = options.customProxy) !== null && _a !== void 0 ? _a : contractName, options);
            if (contractAddress) {
                logger.debug(`Custom address ${contractAddress} specified`);
                if (!artifact.networks[`${options.networkId}`]) {
                    artifact.networks[`${options.networkId}`] = {};
                }
                artifact.networks[`${options.networkId}`].address = contractAddress;
            }
            (0, util_1.enforceOrThrow)(artifact.networks && artifact.networks[`${options.networkId}`], `No instance of contract ${artifact.contractName} found for network id ${options.networkId}`);
            const proxyImplementationAddress = yield (0, util_1.getImplementationAddress)(artifact.networks[`${options.networkId}`].address, logger, options.provider);
            let status = proxyImplementationAddress
                ? yield verifyProxyContract(artifact, contractName, proxyImplementationAddress, options)
                : yield verifyContract(artifact, options);
            if (status === constants_1.VerificationStatus.FAILED) {
                failedContracts.push(`${contractNameAddressPair}`);
            }
            else if (options.explorerUrl) {
                // Add link to verified contract on Etherscan
                const explorerUrl = `${options.explorerUrl}/${artifact.networks[`${options.networkId}`].address}#code`;
                status += `: ${explorerUrl}`;
            }
            logger.info(status);
        }
        catch (error) {
            logger.error(error.message);
            failedContracts.push(contractNameAddressPair);
        }
        logger.info();
    }
    (0, util_1.enforce)(failedContracts.length === 0, `Failed to verify ${failedContracts.length} contract(s): ${failedContracts.join(', ')}`, logger);
    logger.info(`Successfully verified ${contractNameAddressPairs.length} contract(s).`);
});
const parseConfig = (config) => __awaiter(void 0, void 0, void 0, function* () {
    const provider = config.provider;
    const networkConfig = config.networks && config.networks[config.network];
    const { chainId, networkId } = yield (0, util_1.getNetwork)(config, logger);
    let apiUrl = constants_1.API_URLS[chainId];
    if (networkConfig && networkConfig.verify && networkConfig.verify.apiUrl) {
        apiUrl = networkConfig.verify.apiUrl;
    }
    (0, util_1.enforce)(apiUrl, `Etherscan has no support for network ${config.network} with chain id ${chainId}`, logger);
    const apiKey = (0, util_1.getApiKey)(config, apiUrl, logger);
    let explorerUrl = constants_1.EXPLORER_URLS[chainId];
    if (networkConfig && networkConfig.verify && networkConfig.verify.explorerUrl) {
        explorerUrl = networkConfig.verify.explorerUrl;
    }
    (0, util_1.enforce)(config._.length > 1, 'No contract name(s) specified', logger);
    (0, util_1.enforce)(networkId !== '*', 'network_id bypassed with "*" in truffle-config.js.', logger);
    const projectDir = config.working_directory;
    const contractsBuildDir = config.contracts_build_directory;
    const contractsDir = config.contracts_directory;
    const customProxy = config['custom-proxy'];
    let forceConstructorArgsType, forceConstructorArgs;
    if (config.forceConstructorArgs) {
        [forceConstructorArgsType, forceConstructorArgs] = String(config.forceConstructorArgs).split(':');
        (0, util_1.enforce)(forceConstructorArgsType === 'string', 'Force constructor args must be string type', logger);
        logger.debug(`Force custructor args provided: 0x${forceConstructorArgs}`);
    }
    return {
        apiUrl,
        apiKey,
        explorerUrl,
        networkId,
        chainId,
        provider,
        projectDir,
        contractsBuildDir,
        contractsDir,
        forceConstructorArgs,
        customProxy,
    };
});
const getArtifact = (contractName, options) => {
    const artifactPath = path_1.default.resolve(options.contractsBuildDir, `${contractName}.json`);
    logger.debug(`Reading artifact file at ${artifactPath}`);
    (0, util_1.enforceOrThrow)(fs_1.default.existsSync(artifactPath), `Could not find ${contractName} artifact at ${artifactPath}`);
    // Stringify + parse to make a deep copy (to avoid bugs with PR #19)
    return JSON.parse(JSON.stringify(require(artifactPath)));
};
const verifyContract = (artifact, options) => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield sendVerifyRequest(artifact, options);
    (0, util_1.enforceOrThrow)(res.data, `Failed to connect to Etherscan API at url ${options.apiUrl}`);
    if (res.data.result === constants_1.VerificationStatus.ALREADY_VERIFIED) {
        return constants_1.VerificationStatus.ALREADY_VERIFIED;
    }
    (0, util_1.enforceOrThrow)(res.data.status === constants_1.RequestStatus.OK, res.data.result);
    return verificationStatus(res.data.result, options);
});
const sendVerifyRequest = (artifact, options) => __awaiter(void 0, void 0, void 0, function* () {
    const compilerVersion = extractCompilerVersion(artifact);
    const encodedConstructorArgs = options.forceConstructorArgs !== undefined
        ? options.forceConstructorArgs
        : yield fetchConstructorValues(artifact, options);
    const inputJSON = getInputJSON(artifact, options);
    // Remove the 'project:' prefix that was added in Truffle v5.3.14
    const relativeFilePath = artifact.ast.absolutePath.replace('project:', '');
    const postQueries = {
        apikey: options.apiKey,
        module: 'contract',
        action: 'verifysourcecode',
        contractaddress: artifact.networks[`${options.networkId}`].address,
        sourceCode: JSON.stringify(inputJSON),
        codeformat: 'solidity-standard-json-input',
        contractname: `${relativeFilePath}:${artifact.contractName}`,
        compilerversion: compilerVersion,
        constructorArguements: encodedConstructorArgs,
    };
    try {
        logger.debug('Sending verify request with POST arguments:');
        logger.debug(JSON.stringify(postQueries, null, 2));
        return yield axios_1.default.post(options.apiUrl, querystring_1.default.stringify(postQueries));
    }
    catch (error) {
        logger.debug(error.message);
        throw new Error(`Failed to connect to Etherscan API at url ${options.apiUrl}`);
    }
});
const extractCompilerVersion = (artifact) => {
    const metadata = JSON.parse(artifact.metadata);
    const compilerVersion = `v${metadata.compiler.version}`;
    return compilerVersion;
};
const fetchConstructorValues = (artifact, options) => __awaiter(void 0, void 0, void 0, function* () {
    const contractAddress = artifact.networks[`${options.networkId}`].address;
    // Fetch the contract creation transaction to extract the input data
    let res;
    try {
        const qs = querystring_1.default.stringify({
            apiKey: options.apiKey,
            module: 'account',
            action: 'txlist',
            address: contractAddress,
            page: 1,
            sort: 'asc',
            offset: 1,
        });
        const url = `${options.apiUrl}?${qs}`;
        logger.debug(`Retrieving constructor parameters from ${url}`);
        res = yield axios_1.default.get(url);
    }
    catch (error) {
        logger.debug(error.message);
        throw new Error(`Failed to connect to Etherscan API at url ${options.apiUrl}`);
    }
    // The last part of the transaction data is the constructor arguments
    // If it can't be accessed for any reason, try using empty constructor arguments
    if (res.data && res.data.status === constants_1.RequestStatus.OK && res.data.result[0] !== undefined) {
        const constructorArgs = res.data.result[0].input.substring(artifact.bytecode.length);
        logger.debug(`Constructor parameters retrieved: 0x${constructorArgs}`);
        return constructorArgs;
    }
    else {
        logger.debug('Could not retrieve constructor parameters, using empty parameters as fallback');
        return '';
    }
});
const getInputJSON = (artifact, options) => {
    const metadata = JSON.parse(artifact.metadata);
    const libraries = getLibraries(artifact, options);
    // Sort the source files so that the "main" contract is on top
    const orderedSources = Object.keys(metadata.sources)
        .reverse()
        .sort((a, b) => {
        if (a === artifact.ast.absolutePath)
            return -1;
        if (b === artifact.ast.absolutePath)
            return 1;
        return 0;
    });
    const sources = {};
    for (const contractPath of orderedSources) {
        // If we're on Windows we need to de-Unixify the path so that Windows can read the file
        // We also need to replace the 'project:' prefix so that the file can be read
        const normalisedContractPath = (0, util_1.normaliseContractPath)(contractPath, options);
        const absolutePath = require.resolve(normalisedContractPath, { paths: [options.projectDir] });
        const content = fs_1.default.readFileSync(absolutePath, 'utf8');
        // Remove the 'project:' prefix that was added in Truffle v5.3.14
        const relativeContractPath = contractPath.replace('project:', '');
        sources[relativeContractPath] = { content };
    }
    const inputJSON = {
        language: metadata.language,
        sources,
        settings: {
            remappings: metadata.settings.remappings,
            optimizer: metadata.settings.optimizer,
            evmVersion: metadata.settings.evmVersion,
            libraries,
        },
    };
    return inputJSON;
};
const getLibraries = (artifact, options) => {
    const libraries = {
    // Example data structure of libraries object in Standard Input JSON
    // 'ConvertLib.sol': {
    //   'ConvertLib': '0x...',
    //   'OtherLibInSameSourceFile': '0x...'
    // }
    };
    const links = artifact.networks[`${options.networkId}`].links || {};
    for (const libraryName in links) {
        // Retrieve the source path for this library
        const libraryArtifact = getArtifact(libraryName, options);
        // Remove the 'project:' prefix that was added in Truffle v5.3.14
        const librarySourceFile = libraryArtifact.ast.absolutePath.replace('project:', '');
        // Add the library to the object of libraries for this source path
        const librariesForSourceFile = libraries[librarySourceFile] || {};
        librariesForSourceFile[libraryName] = links[libraryName];
        libraries[librarySourceFile] = librariesForSourceFile;
    }
    return libraries;
};
const verificationStatus = (guid, options, action = 'checkverifystatus') => __awaiter(void 0, void 0, void 0, function* () {
    logger.debug(`Checking status of verification request ${guid}`);
    // Retry API call every second until status is no longer pending
    while (true) {
        yield (0, delay_1.default)(1000);
        try {
            const qs = querystring_1.default.stringify({
                apiKey: options.apiKey,
                module: 'contract',
                action,
                guid,
            });
            const verificationResult = yield axios_1.default.get(`${options.apiUrl}?${qs}`);
            if (verificationResult.data.result !== constants_1.VerificationStatus.PENDING) {
                return verificationResult.data.result;
            }
        }
        catch (error) {
            logger.debug(error.message);
            throw new Error(`Failed to connect to Etherscan API at url ${options.apiUrl}`);
        }
    }
});
const verifyProxyContract = (proxyArtifact, implementationName, implementationAddress, options) => __awaiter(void 0, void 0, void 0, function* () {
    if (options.customProxy) {
        logger.info(`Verifying custom proxy contract ${options.customProxy} at ${proxyArtifact.networks[`${options.networkId}`].address}`);
        const status = yield verifyContract(proxyArtifact, options);
        if (status === constants_1.VerificationStatus.FAILED)
            return status;
    }
    const implementationArtifact = (0, util_1.deepCopy)(getArtifact(implementationName, options));
    implementationArtifact.networks[`${options.networkId}`] = {
        address: implementationAddress,
    };
    logger.info(`Verifying proxy implementation ${implementationName} at ${implementationAddress}`);
    const status = yield verifyContract(implementationArtifact, options);
    if ([
        constants_1.VerificationStatus.SUCCESS,
        constants_1.VerificationStatus.ALREADY_VERIFIED,
        constants_1.VerificationStatus.AUTOMATICALLY_VERIFIED,
    ].includes(status)) {
        logger.info('Linking proxy and implementation addresses');
        yield verifyProxy(proxyArtifact.networks[`${options.networkId}`].address, options);
    }
    return status;
});
const verifyProxy = (proxyAddress, options) => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield sendProxyVerifyRequest(proxyAddress, options);
    (0, util_1.enforceOrThrow)(res.data, `Failed to connect to Etherscan API at url ${options.apiUrl}`);
    (0, util_1.enforceOrThrow)(res.data.status === constants_1.RequestStatus.OK, res.data.result);
    const status = yield verificationStatus(res.data.result, options, 'checkproxyverification');
    logger.debug(status);
});
const sendProxyVerifyRequest = (address, options) => __awaiter(void 0, void 0, void 0, function* () {
    const postQueries = { address };
    const qs = querystring_1.default.stringify({
        apiKey: options.apiKey,
        module: 'contract',
        action: 'verifyproxycontract',
    });
    try {
        logger.debug(`Sending verify proxy request to ${options.apiUrl}?${qs} with POST arguments:`);
        logger.debug(JSON.stringify(postQueries, null, 2));
        return yield axios_1.default.post(`${options.apiUrl}?${qs}`, querystring_1.default.stringify(postQueries));
    }
    catch (error) {
        logger.info(error.message);
        throw new Error(`Failed to connect to Etherscan API at url ${options.apiUrl}`);
    }
});
